**[https://www.cs.kent.ac.uk/pubs/2007/2798/content.pdf](https://www.cs.kent.ac.uk/pubs/2007/2798/content.pdf)

We can also distinguish between disciplines in which there is an emphasis on learning through interpreting and those in which learning is predominantly achieved through doing. Economics and Theology could be seen as examples of the former, Dance and Music performance of the latter. This is not to suggest that Economics and Theology do not require their students to do it in the sense of repeatedly writing essays; however they are learning about the practice of the subject rather than running an economy or developing a new religion. Computing students are expected to do a lot of learning through doing, whether it is learning about software engineering by developing systems of increasing complexity, learning about networking by implementing protocols or learning about group dynamics by working in teams. 

There are several other characteristics that apply specifically to computer science as discipline. First, and perhaps foremost, studying processes and problem solutions is very central to, if not the essence of, computer science. One could say that solving problems and producing an effective and efficient solution is the core goal of a computer science professional. 

Computer science centrally involves modeling the real world, representing domains of the most varied nature and complexity, representing knowledge in general and dealing with processes and solutions for problems in such domains. In order to address the complexities of the problems and domains, there is an essential need to abstract and decompose problems into subproblems and modules. Abstraction, modularity and reusage of previous solutions constitute essential abilities needed by any computer science researcher or professional. 

Other characteristics of computer science are creativity and openness to novelty, considering that they are inherently related to finding solutions to problems. It is also worthy of notice that computer science is becoming more and more multidisciplinary, and hence professionals and academics need good communication skills not only among themselves but also with experts in other disciplines.

The inspiration for this taxonomy was research [41,73] indicating that comprehension of program code and the ability to produce program code are two semi-independent capabilities. Students who can read programs may not necessarily be able to write programs of their own. And the ability to write program code does not imply the ability to debug it. Robins et al. [63] describe this independent interpretive skill as the ability to distinguish the intended behavior of the program from the actual behavior of the program. 

We used the revised version of Bloom’s taxonomy [6] which responded to problems with the linear approach at the higher levels. It provides a level of creation (Higher Application) which requires competency at all the previous levels and one that does not (Create). In order to visualize this distinction and the semi-independent skills of reading and writing program code, our taxonomy employs a two dimensional matrix with an adaptation of Bloom’s taxonomy which is presented in Figure below.

![](https://lh7-us.googleusercontent.com/lr8d562QQjmW_Ln-zTRYgWXBInrTeWh4Ri203VBjnqu91sWUbZmi1qMw3MIXQ4cmt9ebzsK9XPO7r0YPv1DCoe6PECYwt84srKrU41gvR2ws3y3r68p9Ey3S4dqutVxskVFfqaKnNSF3nOoCgfPDrQ)

The dimensions of the matrix represent the two separate ranges of competencies: the ability to understand and interpret an existing product (i.e. program code), and the ability to design and build a new product. Levels related to interpretation are placed on the horizontal axis and levels related to generation are placed on the vertical axis, with the lowest levels at the lower left corner. The names of the levels are from the revised version of Bloom’s, as we feel they are sufficiently unambiguous. It is understood that students traverse each axis in strict sequence. For example, it is not possible to begin to do synthesis (Create) until there is some degree of competency through the Apply Level. 

![](https://lh7-us.googleusercontent.com/obIPXmo2fGku1mHmyHdE_e8lCmc-NgFxvrshbJ7qT7ECQYBqSvUaNkqjcs9lVgQWwOwyIDShtk9EnY6NWMIPVzcBAoE4v_j4EF3SNXjDXwQnvtzyZxEeZ3tbqW-fNsoPcr0Wfdb9-8GFgjsja-xAGA)![](https://lh7-us.googleusercontent.com/U4s-0E8lHJQLrl30zFN6XLCiCy4aE7Z8ObBAOyW3ckLePiSvZFkNaCjxAyleNFQ57BwHgQapdJi5Xx_R0szYSULHhwjUi0GEYrK_IXmxBHOYIuR7K3cQkDVu59hMc5ltAK5Xlm44QEn-VqSSO4fAMQ)

  

![](https://lh7-us.googleusercontent.com/uCQD4Hxp7KHbR0S_p3068JDfwvFmhzv3tw8JVPqbfs1RwMpdW1GZZ6Y6S1IarKTSY8jRWq6qYZJZsnkfRq_edAnuzXJk65YP6rugtgED47TKgsw_cqGnorvEi5GFi41mDXT-XiwDxgF-6n3i71lB9g)![](https://lh7-us.googleusercontent.com/b-gw77QnaQzJB1LVx5_tUGE5tSm7kj4-6ud3FiP6EFhFaIuh-L4KS-uhlhf0i3FRbEzu5W7NpJzP1crdYtdJXH0VxUgmK_cgvqfCNQTHay5TFVdshgQOfhkOLR_PF9jtGP24JfIkCUARYPS5_JQU5Q)

Mapping Programming Activities to the Matrix We provide a mapping from a set of computer programming activities to the cells of the matrix in order to illustrate the discriminatory power of the proposed taxonomy for this subject area. This is done with a list of problem-solving activities related to programming collected as a reaction to difficulties encountered in using Bloom’s Taxonomy. The activities shown in Table 1 are mapped to the cells of the taxonomy. See Figure 7.

![](https://lh7-us.googleusercontent.com/1QAHpXulLBkK8QogjjXKmeDvQqNFuiOtrpii_X4LM9_mFqsBxv_B4VEaoERxk2sZUb0K59pbNacnwJXfTO6L32KsHxvWRTNS1fBHOb9DkbgfvvuPxMzR7_W7VRk_WfQNduPVRPlAk898FORSaIUT1Q)

![](https://lh7-us.googleusercontent.com/OF4lPyV2uXfZaa3adfE_yHE_V-BqGFf78OhvBGJrOvhdV0WSvrykoRVpeRG0qmKmxl36yVv5a8_4bE7rG59wwomH0OXoXpqfh0FoxjkWk448dW4PxNwbRdzO_k39oYS7TJt6GzDZmp-eZZ1EgPyg3A)

I think this is the best taxonomy:

# Applying Taxonomies Iteratively - a Spiral Architecture for Applying a Learning Taxonomy 

Robins at al. describe a schema as “a structured chunk of related knowledge” [63]. The student's learning goes through learning new schemas, modifying and combining them in order to produce new, more abstract schemas. Thus, the learning of programming could be seen as an iterative process. In the very beginning, the student is taught really simplistic and basic pieces of information and places to apply them. Instead of learning some things here and there, programming is a skill that is learned by building new information on top of earlier information. So in a way the basic pieces of information students are first struggling with become the bits and pieces they use in subsequent learning of new material. Compared to other cyclic learning styles e.g. the experimental learning style described by Kolb’s Learning Cycle [30], the idea here is to proceed to a new level after each cycle. 

The idea of a cognitive learning taxonomy can also be used in an iterative, spiral way. When the student is learning the basic concepts and the simplest subjects, he is going through the taxonomy in respect of that subject only. After having created a schema on that subject, he is then guided into a more abstract subject. When looking only at this new subject, the student is starting again from the lowest level of taxonomy—but now using the earlier material as a prerequisite. 

The spiral process could be applied to Bloom's taxonomy, in that when the student is learning a new subject, his prerequisites—the materials to use in building new knowledge—have become his new basic knowledge, although the student has perhaps reached the level Create or Evaluate on those earlier subjects. Create could be described as the ability to combine one subject with others in order to build new solutions. This may also be seen when new solutions or subjects are learnt by building upon and integrating previous knowledge. This is easily seen to be true when considering that topics that are difficult and require in-depth analyzing by students are mere basic knowledge for expert programmers. Applying Bloom’s taxonomy iteratively is illustrated in Figure 8. 

Here is an example of a learning spiral: In the beginning a programming student is taught how to use a loop structure. He will go through all the levels of Bloom's taxonomy while learning it. He knows that a loop can be used for iteration; he understands how the loop works; he is able to apply a loop when told etc., eventually learning it thoroughly. After reaching the highest levels, the loop structure has become a tool for the student to use in subsequent programming. As the student is trying to learn how to sort an array, the loop can be seen as his basis of knowledge upon which he is building his new knowledge. Later as the student is trying to implement a top-application to his own operating system, he will use the sorting of an array as a part of his base knowledge.

Traditionally programming has been taught starting with low levels of abstraction, moving on bit-by-bit to higher abstractions. For example, consider learning expressions, loop structures, functions, classes, design patterns etc. There are still many situations where one returns for more in-depth learning. Using a high level programming language itself establishes a starting level of abstraction, and using the objects-first approach immediately raises that level. The spiral approach with learning taxonomies must not be seen as going directly from bottom to top, but by seeing each round as thoroughly learning some new piece of information which is then used as a basis for the next round in the topic. It is of benefit to know how to write functions using C++ when one is trying to do something similar but more challenging with a lower level language such as Assembly, because then one already has knowledge of procedures, functions, parameters and return values.

The spiral application of a taxonomy is not limited to any particular taxonomy such as Bloom's. One round of the spiral (the learning of a new schema) could be described by any taxonomy suitable for describing students’ abilities in that subject. For instance, the Matrix taxonomy proposed in subsection 1 could be applied in a spiral way. One learning path from the elementary level “none/Remember” to the Higher Application level “Create/Evaluate” can be seen as one round of the spiral. When rising to a higher abstraction level, the student starts his “ learning path” once again from the lower left corner.

  

![](https://lh7-us.googleusercontent.com/jx0Rxh61gdleiJbuCT7V7fY1HfP_kkGQEzrncj_AJrmzATd_GnXgQhpG5goDpHxfQ1YlO8_vL0CCltrXdbqeI9zdzyxHy_yfmBqVMG5-sU4m2YEEdbb2ZbU1q3uJ_m84P0Xv2p0q4S6Wg6cs1pMRWA)

When trying to move up a level of abstraction (as in to start a new round of the spiral) the student may not have reached the Higher Application level “Create/Evaluate”. To use his skills as a basic knowledge for the next, more abstract round the student may well be in one of the nearby cells, such as “Create/Analyse”. While already progressing in the next round (with a more abstract subject), the student may eventually reach the “Create/Evaluate” state of the earlier level through his experience in using it. Thus the two rounds would in a way be followed in parallel for a while. On the other hand, if the student has taken one of the less desirable learning paths illustrated in Figures 3 and 4 (theoretical or practical only) and attempts to progress to the next round, he could be building his knowledge on misconceptions and may later face problems.**